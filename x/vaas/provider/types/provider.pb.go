// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vaas/provider/v1/provider.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	_ "cosmossdk.io/x/evidence/types"
	fmt "fmt"
	types "github.com/allinbits/vaas/x/vaas/types"
	crypto "github.com/cometbft/cometbft/proto/tendermint/crypto"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	types1 "github.com/cosmos/ibc-go/v10/modules/core/02-client/types"
	_07_tendermint "github.com/cosmos/ibc-go/v10/modules/light-clients/07-tendermint"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ConsumerPhase indicates the phases of a consumer chain according to ADR 019
type ConsumerPhase int32

const (
	// UNSPECIFIED defines an empty phase.
	CONSUMER_PHASE_UNSPECIFIED ConsumerPhase = 0
	// REGISTERED defines the phase in which a consumer chain has been assigned a
	// unique consumer id. A chain in this phase cannot yet launch.
	CONSUMER_PHASE_REGISTERED ConsumerPhase = 1
	// INITIALIZED defines the phase in which a consumer chain has set all the
	// needed parameters to launch but has not yet launched (e.g., because the
	// `spawnTime` of the consumer chain has not yet been reached).
	CONSUMER_PHASE_INITIALIZED ConsumerPhase = 2
	// LAUNCHED defines the phase in which a consumer chain is running and
	// consuming a subset of the validator set of the provider.
	CONSUMER_PHASE_LAUNCHED ConsumerPhase = 3
	// STOPPED defines the phase in which a previously-launched chain has stopped.
	CONSUMER_PHASE_STOPPED ConsumerPhase = 4
	// DELETED defines the phase in which the state of a stopped chain has been
	// deleted.
	CONSUMER_PHASE_DELETED ConsumerPhase = 5
)

var ConsumerPhase_name = map[int32]string{
	0: "CONSUMER_PHASE_UNSPECIFIED",
	1: "CONSUMER_PHASE_REGISTERED",
	2: "CONSUMER_PHASE_INITIALIZED",
	3: "CONSUMER_PHASE_LAUNCHED",
	4: "CONSUMER_PHASE_STOPPED",
	5: "CONSUMER_PHASE_DELETED",
}

var ConsumerPhase_value = map[string]int32{
	"CONSUMER_PHASE_UNSPECIFIED": 0,
	"CONSUMER_PHASE_REGISTERED":  1,
	"CONSUMER_PHASE_INITIALIZED": 2,
	"CONSUMER_PHASE_LAUNCHED":    3,
	"CONSUMER_PHASE_STOPPED":     4,
	"CONSUMER_PHASE_DELETED":     5,
}

func (x ConsumerPhase) String() string {
	return proto.EnumName(ConsumerPhase_name, int32(x))
}

func (ConsumerPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{0}
}

// Params defines the parameters for VAAS Provider module
type Params struct {
	TemplateClient *_07_tendermint.ClientState `protobuf:"bytes,1,opt,name=template_client,json=templateClient,proto3" json:"template_client,omitempty"`
	// TrustingPeriodFraction is used to compute the consumer and provider IBC
	// client's TrustingPeriod from the chain defined UnbondingPeriod
	TrustingPeriodFraction string `protobuf:"bytes,2,opt,name=trusting_period_fraction,json=trustingPeriodFraction,proto3" json:"trusting_period_fraction,omitempty"`
	// Sent IBC packets will timeout after this duration
	VaasTimeoutPeriod time.Duration `protobuf:"bytes,3,opt,name=vaas_timeout_period,json=vaasTimeoutPeriod,proto3,stdduration" json:"vaas_timeout_period"`
	// The number of blocks that comprise an epoch.
	BlocksPerEpoch int64 `protobuf:"varint,4,opt,name=blocks_per_epoch,json=blocksPerEpoch,proto3" json:"blocks_per_epoch,omitempty"`
	// The maximal number of validators that will be passed
	// to the consensus engine on the provider.
	MaxProviderConsensusValidators int64 `protobuf:"varint,5,opt,name=max_provider_consensus_validators,json=maxProviderConsensusValidators,proto3" json:"max_provider_consensus_validators,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetTemplateClient() *_07_tendermint.ClientState {
	if m != nil {
		return m.TemplateClient
	}
	return nil
}

func (m *Params) GetTrustingPeriodFraction() string {
	if m != nil {
		return m.TrustingPeriodFraction
	}
	return ""
}

func (m *Params) GetVaasTimeoutPeriod() time.Duration {
	if m != nil {
		return m.VaasTimeoutPeriod
	}
	return 0
}

func (m *Params) GetBlocksPerEpoch() int64 {
	if m != nil {
		return m.BlocksPerEpoch
	}
	return 0
}

func (m *Params) GetMaxProviderConsensusValidators() int64 {
	if m != nil {
		return m.MaxProviderConsensusValidators
	}
	return 0
}

// AddressList contains a list of consensus addresses
type AddressList struct {
	Addresses [][]byte `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
}

func (m *AddressList) Reset()         { *m = AddressList{} }
func (m *AddressList) String() string { return proto.CompactTextString(m) }
func (*AddressList) ProtoMessage()    {}
func (*AddressList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{1}
}
func (m *AddressList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressList.Merge(m, src)
}
func (m *AddressList) XXX_Size() int {
	return m.Size()
}
func (m *AddressList) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressList.DiscardUnknown(m)
}

var xxx_messageInfo_AddressList proto.InternalMessageInfo

func (m *AddressList) GetAddresses() [][]byte {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// ValidatorSetChangePackets is a pb list of ccv.ValidatorSetChangePacketData.
type ValidatorSetChangePackets struct {
	List []types.ValidatorSetChangePacketData `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
}

func (m *ValidatorSetChangePackets) Reset()         { *m = ValidatorSetChangePackets{} }
func (m *ValidatorSetChangePackets) String() string { return proto.CompactTextString(m) }
func (*ValidatorSetChangePackets) ProtoMessage()    {}
func (*ValidatorSetChangePackets) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{2}
}
func (m *ValidatorSetChangePackets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSetChangePackets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSetChangePackets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSetChangePackets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSetChangePackets.Merge(m, src)
}
func (m *ValidatorSetChangePackets) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSetChangePackets) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSetChangePackets.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSetChangePackets proto.InternalMessageInfo

func (m *ValidatorSetChangePackets) GetList() []types.ValidatorSetChangePacketData {
	if m != nil {
		return m.List
	}
	return nil
}

type KeyAssignmentReplacement struct {
	ProviderAddr []byte            `protobuf:"bytes,1,opt,name=provider_addr,json=providerAddr,proto3" json:"provider_addr,omitempty"`
	PrevCKey     *crypto.PublicKey `protobuf:"bytes,2,opt,name=prev_c_key,json=prevCKey,proto3" json:"prev_c_key,omitempty"`
	Power        int64             `protobuf:"varint,3,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *KeyAssignmentReplacement) Reset()         { *m = KeyAssignmentReplacement{} }
func (m *KeyAssignmentReplacement) String() string { return proto.CompactTextString(m) }
func (*KeyAssignmentReplacement) ProtoMessage()    {}
func (*KeyAssignmentReplacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{3}
}
func (m *KeyAssignmentReplacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyAssignmentReplacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyAssignmentReplacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyAssignmentReplacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyAssignmentReplacement.Merge(m, src)
}
func (m *KeyAssignmentReplacement) XXX_Size() int {
	return m.Size()
}
func (m *KeyAssignmentReplacement) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyAssignmentReplacement.DiscardUnknown(m)
}

var xxx_messageInfo_KeyAssignmentReplacement proto.InternalMessageInfo

func (m *KeyAssignmentReplacement) GetProviderAddr() []byte {
	if m != nil {
		return m.ProviderAddr
	}
	return nil
}

func (m *KeyAssignmentReplacement) GetPrevCKey() *crypto.PublicKey {
	if m != nil {
		return m.PrevCKey
	}
	return nil
}

func (m *KeyAssignmentReplacement) GetPower() int64 {
	if m != nil {
		return m.Power
	}
	return 0
}

// Used to serialize the ValidatorConsumerPubKey index from key assignment
// ValidatorConsumerPubKey: (chainID, providerAddr consAddr) -> consumerKey
// tmprotocrypto.PublicKey
type ValidatorConsumerPubKey struct {
	ChainId      string            `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	ProviderAddr []byte            `protobuf:"bytes,2,opt,name=provider_addr,json=providerAddr,proto3" json:"provider_addr,omitempty"`
	ConsumerKey  *crypto.PublicKey `protobuf:"bytes,3,opt,name=consumer_key,json=consumerKey,proto3" json:"consumer_key,omitempty"`
}

func (m *ValidatorConsumerPubKey) Reset()         { *m = ValidatorConsumerPubKey{} }
func (m *ValidatorConsumerPubKey) String() string { return proto.CompactTextString(m) }
func (*ValidatorConsumerPubKey) ProtoMessage()    {}
func (*ValidatorConsumerPubKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{4}
}
func (m *ValidatorConsumerPubKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorConsumerPubKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorConsumerPubKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorConsumerPubKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorConsumerPubKey.Merge(m, src)
}
func (m *ValidatorConsumerPubKey) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorConsumerPubKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorConsumerPubKey.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorConsumerPubKey proto.InternalMessageInfo

func (m *ValidatorConsumerPubKey) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ValidatorConsumerPubKey) GetProviderAddr() []byte {
	if m != nil {
		return m.ProviderAddr
	}
	return nil
}

func (m *ValidatorConsumerPubKey) GetConsumerKey() *crypto.PublicKey {
	if m != nil {
		return m.ConsumerKey
	}
	return nil
}

// Used to serialize the ValidatorConsumerAddr index from key assignment
// ValidatorByConsumerAddr: (chainID, consumerAddr consAddr) -> providerAddr
// consAddr
type ValidatorByConsumerAddr struct {
	ChainId      string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	ConsumerAddr []byte `protobuf:"bytes,2,opt,name=consumer_addr,json=consumerAddr,proto3" json:"consumer_addr,omitempty"`
	ProviderAddr []byte `protobuf:"bytes,3,opt,name=provider_addr,json=providerAddr,proto3" json:"provider_addr,omitempty"`
}

func (m *ValidatorByConsumerAddr) Reset()         { *m = ValidatorByConsumerAddr{} }
func (m *ValidatorByConsumerAddr) String() string { return proto.CompactTextString(m) }
func (*ValidatorByConsumerAddr) ProtoMessage()    {}
func (*ValidatorByConsumerAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{5}
}
func (m *ValidatorByConsumerAddr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorByConsumerAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorByConsumerAddr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorByConsumerAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorByConsumerAddr.Merge(m, src)
}
func (m *ValidatorByConsumerAddr) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorByConsumerAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorByConsumerAddr.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorByConsumerAddr proto.InternalMessageInfo

func (m *ValidatorByConsumerAddr) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ValidatorByConsumerAddr) GetConsumerAddr() []byte {
	if m != nil {
		return m.ConsumerAddr
	}
	return nil
}

func (m *ValidatorByConsumerAddr) GetProviderAddr() []byte {
	if m != nil {
		return m.ProviderAddr
	}
	return nil
}

// Used to serialize the ConsumerAddrsToPrune index from key assignment
// ConsumerAddrsToPrune: (chainID, pruneTs time.Time) -> consumerAddrs
// AddressList
type ConsumerAddrsToPrune struct {
	ChainId       string       `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	PruneTs       time.Time    `protobuf:"bytes,2,opt,name=prune_ts,json=pruneTs,proto3,stdtime" json:"prune_ts"`
	ConsumerAddrs *AddressList `protobuf:"bytes,3,opt,name=consumer_addrs,json=consumerAddrs,proto3" json:"consumer_addrs,omitempty"`
}

func (m *ConsumerAddrsToPrune) Reset()         { *m = ConsumerAddrsToPrune{} }
func (m *ConsumerAddrsToPrune) String() string { return proto.CompactTextString(m) }
func (*ConsumerAddrsToPrune) ProtoMessage()    {}
func (*ConsumerAddrsToPrune) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{6}
}
func (m *ConsumerAddrsToPrune) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerAddrsToPrune) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerAddrsToPrune.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsumerAddrsToPrune) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerAddrsToPrune.Merge(m, src)
}
func (m *ConsumerAddrsToPrune) XXX_Size() int {
	return m.Size()
}
func (m *ConsumerAddrsToPrune) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerAddrsToPrune.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerAddrsToPrune proto.InternalMessageInfo

func (m *ConsumerAddrsToPrune) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ConsumerAddrsToPrune) GetPruneTs() time.Time {
	if m != nil {
		return m.PruneTs
	}
	return time.Time{}
}

func (m *ConsumerAddrsToPrune) GetConsumerAddrs() *AddressList {
	if m != nil {
		return m.ConsumerAddrs
	}
	return nil
}

// ConsensusValidator is used to express a validator that
// should be validating on a chain.
// It contains relevant info for
// a validator that is expected to validate on
// either the provider or a consumer chain.
type ConsensusValidator struct {
	// validator's consensus address on the provider chain
	ProviderConsAddr []byte `protobuf:"bytes,1,opt,name=provider_cons_addr,json=providerConsAddr,proto3" json:"provider_cons_addr,omitempty"`
	// voting power the validator has during this epoch
	Power int64 `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
	// public key the validator uses on the consumer chain during this epoch
	PublicKey *crypto.PublicKey `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// height the validator had when it FIRST became a consumer validator
	// If a validator becomes a consumer validator at height `H` and is
	// continuously a consumer validator for all the upcoming epochs, then the
	// height of the validator SHOULD remain `H`. This height only resets to a
	// different height if a validator stops being a consumer validator during an
	// epoch and later becomes again a consumer validator.
	JoinHeight int64 `protobuf:"varint,4,opt,name=join_height,json=joinHeight,proto3" json:"join_height,omitempty"`
}

func (m *ConsensusValidator) Reset()         { *m = ConsensusValidator{} }
func (m *ConsensusValidator) String() string { return proto.CompactTextString(m) }
func (*ConsensusValidator) ProtoMessage()    {}
func (*ConsensusValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{7}
}
func (m *ConsensusValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusValidator.Merge(m, src)
}
func (m *ConsensusValidator) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusValidator.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusValidator proto.InternalMessageInfo

func (m *ConsensusValidator) GetProviderConsAddr() []byte {
	if m != nil {
		return m.ProviderConsAddr
	}
	return nil
}

func (m *ConsensusValidator) GetPower() int64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *ConsensusValidator) GetPublicKey() *crypto.PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *ConsensusValidator) GetJoinHeight() int64 {
	if m != nil {
		return m.JoinHeight
	}
	return 0
}

// ConsumerMetadata contains general information about the registered chain
type ConsumerMetadata struct {
	// the name of the chain
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the description of the chain
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// the metadata (e.g., GitHub repository URL) of the chain
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *ConsumerMetadata) Reset()         { *m = ConsumerMetadata{} }
func (m *ConsumerMetadata) String() string { return proto.CompactTextString(m) }
func (*ConsumerMetadata) ProtoMessage()    {}
func (*ConsumerMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{8}
}
func (m *ConsumerMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsumerMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerMetadata.Merge(m, src)
}
func (m *ConsumerMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ConsumerMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerMetadata proto.InternalMessageInfo

func (m *ConsumerMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConsumerMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ConsumerMetadata) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// ConsumerInitializationParameters are the parameters needed to launch a chain
type ConsumerInitializationParameters struct {
	// the proposed initial height of new consumer chain.
	// For a completely new chain, this will be {0,1}. However, it may be
	// different if this is a chain that is converting to a consumer chain.
	InitialHeight types1.Height `protobuf:"bytes,1,opt,name=initial_height,json=initialHeight,proto3" json:"initial_height"`
	// The hash of the consumer chain genesis state without the consumer VAAS
	// module genesis params. It is used for off-chain confirmation of
	// genesis.json validity by validators and other parties.
	GenesisHash []byte `protobuf:"bytes,2,opt,name=genesis_hash,json=genesisHash,proto3" json:"genesis_hash,omitempty"`
	// The hash of the consumer chain binary that should be run by validators on
	// chain initialization. It is used for off-chain confirmation of binary
	// validity by validators and other parties.
	BinaryHash []byte `protobuf:"bytes,3,opt,name=binary_hash,json=binaryHash,proto3" json:"binary_hash,omitempty"`
	// spawn time is the time on the provider chain at which the consumer chain
	// genesis is finalized and all validators will be responsible for starting
	// their consumer chain validator node.
	SpawnTime time.Time `protobuf:"bytes,4,opt,name=spawn_time,json=spawnTime,proto3,stdtime" json:"spawn_time"`
	// Unbonding period for the consumer,
	// which should be smaller than that of the provider in general.
	UnbondingPeriod time.Duration `protobuf:"bytes,5,opt,name=unbonding_period,json=unbondingPeriod,proto3,stdduration" json:"unbonding_period"`
	// Sent VAAS related IBC packets will timeout after this duration
	VaasTimeoutPeriod time.Duration `protobuf:"bytes,6,opt,name=vaas_timeout_period,json=vaasTimeoutPeriod,proto3,stdduration" json:"vaas_timeout_period"`
	// The number of historical info entries to persist in store.
	// This param is a part of the cosmos sdk staking module. In the case of
	// a VAAS enabled consumer chain, the VAAS module acts as the staking module.
	HistoricalEntries int64 `protobuf:"varint,7,opt,name=historical_entries,json=historicalEntries,proto3" json:"historical_entries,omitempty"`
	// The ID of the connection end on the provider chain on top of which the VAAS
	// channel will be established. If connection_id == "", a new client of the
	// consumer chain and a new connection on top of this client are created.
	// Note that a standalone chain can transition to a consumer chain while
	// maintaining existing IBC channels to other chains by providing a valid
	// connection_id.
	ConnectionId string `protobuf:"bytes,8,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
}

func (m *ConsumerInitializationParameters) Reset()         { *m = ConsumerInitializationParameters{} }
func (m *ConsumerInitializationParameters) String() string { return proto.CompactTextString(m) }
func (*ConsumerInitializationParameters) ProtoMessage()    {}
func (*ConsumerInitializationParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{9}
}
func (m *ConsumerInitializationParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerInitializationParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerInitializationParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsumerInitializationParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerInitializationParameters.Merge(m, src)
}
func (m *ConsumerInitializationParameters) XXX_Size() int {
	return m.Size()
}
func (m *ConsumerInitializationParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerInitializationParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerInitializationParameters proto.InternalMessageInfo

func (m *ConsumerInitializationParameters) GetInitialHeight() types1.Height {
	if m != nil {
		return m.InitialHeight
	}
	return types1.Height{}
}

func (m *ConsumerInitializationParameters) GetGenesisHash() []byte {
	if m != nil {
		return m.GenesisHash
	}
	return nil
}

func (m *ConsumerInitializationParameters) GetBinaryHash() []byte {
	if m != nil {
		return m.BinaryHash
	}
	return nil
}

func (m *ConsumerInitializationParameters) GetSpawnTime() time.Time {
	if m != nil {
		return m.SpawnTime
	}
	return time.Time{}
}

func (m *ConsumerInitializationParameters) GetUnbondingPeriod() time.Duration {
	if m != nil {
		return m.UnbondingPeriod
	}
	return 0
}

func (m *ConsumerInitializationParameters) GetVaasTimeoutPeriod() time.Duration {
	if m != nil {
		return m.VaasTimeoutPeriod
	}
	return 0
}

func (m *ConsumerInitializationParameters) GetHistoricalEntries() int64 {
	if m != nil {
		return m.HistoricalEntries
	}
	return 0
}

func (m *ConsumerInitializationParameters) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

// ConsumerIds contains consumer ids of chains
// Used so we can easily (de)serialize slices of strings
type ConsumerIds struct {
	Ids []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
}

func (m *ConsumerIds) Reset()         { *m = ConsumerIds{} }
func (m *ConsumerIds) String() string { return proto.CompactTextString(m) }
func (*ConsumerIds) ProtoMessage()    {}
func (*ConsumerIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{10}
}
func (m *ConsumerIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsumerIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerIds.Merge(m, src)
}
func (m *ConsumerIds) XXX_Size() int {
	return m.Size()
}
func (m *ConsumerIds) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerIds.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerIds proto.InternalMessageInfo

func (m *ConsumerIds) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

type InfractionParameters struct {
	DoubleSign *SlashJailParameters `protobuf:"bytes,1,opt,name=double_sign,json=doubleSign,proto3" json:"double_sign,omitempty"`
	Downtime   *SlashJailParameters `protobuf:"bytes,2,opt,name=downtime,proto3" json:"downtime,omitempty"`
}

func (m *InfractionParameters) Reset()         { *m = InfractionParameters{} }
func (m *InfractionParameters) String() string { return proto.CompactTextString(m) }
func (*InfractionParameters) ProtoMessage()    {}
func (*InfractionParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{11}
}
func (m *InfractionParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfractionParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfractionParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfractionParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfractionParameters.Merge(m, src)
}
func (m *InfractionParameters) XXX_Size() int {
	return m.Size()
}
func (m *InfractionParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_InfractionParameters.DiscardUnknown(m)
}

var xxx_messageInfo_InfractionParameters proto.InternalMessageInfo

func (m *InfractionParameters) GetDoubleSign() *SlashJailParameters {
	if m != nil {
		return m.DoubleSign
	}
	return nil
}

func (m *InfractionParameters) GetDowntime() *SlashJailParameters {
	if m != nil {
		return m.Downtime
	}
	return nil
}

type SlashJailParameters struct {
	SlashFraction cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=slash_fraction,json=slashFraction,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"slash_fraction"`
	// for permanent jailing use 9223372036854775807 which is the largest value a
	// time.Duration can hold (approximately 292 years)
	JailDuration time.Duration `protobuf:"bytes,2,opt,name=jail_duration,json=jailDuration,proto3,stdduration" json:"jail_duration"`
	// Indicates whether the validator should be tombstoned when slashed
	Tombstone bool `protobuf:"varint,3,opt,name=tombstone,proto3" json:"tombstone,omitempty"`
}

func (m *SlashJailParameters) Reset()         { *m = SlashJailParameters{} }
func (m *SlashJailParameters) String() string { return proto.CompactTextString(m) }
func (*SlashJailParameters) ProtoMessage()    {}
func (*SlashJailParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_6404dd5d21545279, []int{12}
}
func (m *SlashJailParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashJailParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashJailParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashJailParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashJailParameters.Merge(m, src)
}
func (m *SlashJailParameters) XXX_Size() int {
	return m.Size()
}
func (m *SlashJailParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashJailParameters.DiscardUnknown(m)
}

var xxx_messageInfo_SlashJailParameters proto.InternalMessageInfo

func (m *SlashJailParameters) GetJailDuration() time.Duration {
	if m != nil {
		return m.JailDuration
	}
	return 0
}

func (m *SlashJailParameters) GetTombstone() bool {
	if m != nil {
		return m.Tombstone
	}
	return false
}

func init() {
	proto.RegisterEnum("vaas.provider.v1.ConsumerPhase", ConsumerPhase_name, ConsumerPhase_value)
	proto.RegisterType((*Params)(nil), "vaas.provider.v1.Params")
	proto.RegisterType((*AddressList)(nil), "vaas.provider.v1.AddressList")
	proto.RegisterType((*ValidatorSetChangePackets)(nil), "vaas.provider.v1.ValidatorSetChangePackets")
	proto.RegisterType((*KeyAssignmentReplacement)(nil), "vaas.provider.v1.KeyAssignmentReplacement")
	proto.RegisterType((*ValidatorConsumerPubKey)(nil), "vaas.provider.v1.ValidatorConsumerPubKey")
	proto.RegisterType((*ValidatorByConsumerAddr)(nil), "vaas.provider.v1.ValidatorByConsumerAddr")
	proto.RegisterType((*ConsumerAddrsToPrune)(nil), "vaas.provider.v1.ConsumerAddrsToPrune")
	proto.RegisterType((*ConsensusValidator)(nil), "vaas.provider.v1.ConsensusValidator")
	proto.RegisterType((*ConsumerMetadata)(nil), "vaas.provider.v1.ConsumerMetadata")
	proto.RegisterType((*ConsumerInitializationParameters)(nil), "vaas.provider.v1.ConsumerInitializationParameters")
	proto.RegisterType((*ConsumerIds)(nil), "vaas.provider.v1.ConsumerIds")
	proto.RegisterType((*InfractionParameters)(nil), "vaas.provider.v1.InfractionParameters")
	proto.RegisterType((*SlashJailParameters)(nil), "vaas.provider.v1.SlashJailParameters")
}

func init() { proto.RegisterFile("vaas/provider/v1/provider.proto", fileDescriptor_6404dd5d21545279) }

var fileDescriptor_6404dd5d21545279 = []byte{
	// 1376 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcf, 0x6f, 0xdb, 0xb6,
	0x1e, 0x8f, 0xe2, 0xb4, 0x75, 0xe8, 0x24, 0x75, 0xd9, 0xa0, 0x75, 0xd2, 0xd6, 0x49, 0xfd, 0xd0,
	0x87, 0xa0, 0x7d, 0x95, 0xe0, 0x3e, 0xe0, 0xe1, 0x61, 0x3b, 0x14, 0x89, 0xad, 0x36, 0x5e, 0xd2,
	0xd4, 0x90, 0xdd, 0x1d, 0x8a, 0x0d, 0x02, 0x25, 0xb1, 0x36, 0x1b, 0x89, 0x14, 0x44, 0xda, 0xa9,
	0x77, 0xd8, 0x79, 0xc7, 0xee, 0x36, 0xec, 0x36, 0xec, 0xb2, 0xe3, 0x0e, 0xc3, 0xb0, 0x3f, 0xa1,
	0xbb, 0x15, 0x3b, 0x0d, 0xc3, 0xd0, 0x0d, 0xe9, 0x61, 0xa7, 0xfd, 0x0f, 0x03, 0x29, 0x4a, 0x56,
	0x93, 0xb4, 0xc8, 0xb0, 0x8b, 0x40, 0x7e, 0xbe, 0xdf, 0x0f, 0xf5, 0xe5, 0xf7, 0x27, 0xc1, 0xda,
	0x18, 0x21, 0x6e, 0xc5, 0x09, 0x1b, 0x93, 0x00, 0x27, 0xd6, 0xb8, 0x99, 0xaf, 0xcd, 0x38, 0x61,
	0x82, 0xc1, 0xaa, 0x54, 0x30, 0x73, 0x70, 0xdc, 0x5c, 0xbd, 0x80, 0x22, 0x42, 0x99, 0xa5, 0xbe,
	0xa9, 0xd2, 0xea, 0xbf, 0x7d, 0xc6, 0x23, 0xc6, 0x2d, 0x2c, 0x95, 0xa8, 0x8f, 0xad, 0x71, 0xd3,
	0xc3, 0x02, 0x35, 0x73, 0x40, 0xeb, 0xad, 0xa4, 0x7a, 0xae, 0xda, 0x59, 0xe9, 0x46, 0x8b, 0x96,
	0x07, 0x6c, 0xc0, 0x52, 0x5c, 0xae, 0x34, 0x5a, 0x1f, 0x30, 0x36, 0x08, 0xb1, 0xa5, 0x76, 0xde,
	0xe8, 0x89, 0x15, 0x8c, 0x12, 0x24, 0x08, 0xa3, 0x5a, 0xbe, 0x76, 0x54, 0x2e, 0x48, 0x84, 0xb9,
	0x40, 0x51, 0x9c, 0x29, 0x10, 0xcf, 0xb7, 0x7c, 0x96, 0x60, 0xcb, 0x0f, 0x09, 0xa6, 0x42, 0xde,
	0x30, 0x5d, 0x69, 0x05, 0x4b, 0x2a, 0x84, 0x64, 0x30, 0x14, 0x29, 0xcc, 0x2d, 0x81, 0x69, 0x80,
	0x93, 0x88, 0xa4, 0xca, 0xd3, 0x9d, 0x26, 0x40, 0xe5, 0xb1, 0x71, 0xd3, 0x3a, 0x20, 0x49, 0x76,
	0xaf, 0xab, 0x05, 0x8e, 0x9f, 0x4c, 0x62, 0xc1, 0xac, 0x7d, 0x3c, 0xd1, 0x57, 0x6b, 0x1c, 0xce,
	0x82, 0xb3, 0x5d, 0x94, 0xa0, 0x88, 0xc3, 0x3e, 0x38, 0x2f, 0x70, 0x14, 0x87, 0x48, 0x60, 0x37,
	0xfd, 0x5f, 0xcd, 0x58, 0x37, 0x36, 0x2a, 0x77, 0x6e, 0x99, 0xc4, 0xf3, 0xcd, 0xa2, 0x1d, 0x66,
	0xe1, 0xcf, 0xe3, 0xa6, 0xd9, 0x52, 0x68, 0x4f, 0x20, 0x81, 0x9d, 0xa5, 0xec, 0x8c, 0x14, 0x84,
	0xff, 0x07, 0x35, 0x91, 0x8c, 0xb8, 0x20, 0x74, 0xe0, 0xc6, 0x38, 0x21, 0x2c, 0x70, 0x9f, 0x24,
	0xc8, 0x97, 0x7e, 0xaa, 0xcd, 0xae, 0x1b, 0x1b, 0xf3, 0xce, 0xa5, 0x4c, 0xde, 0x55, 0xe2, 0x7b,
	0x5a, 0x0a, 0x7b, 0xe0, 0xa2, 0xbc, 0x8e, 0x2b, 0xdd, 0xc6, 0x46, 0x42, 0xb3, 0x6b, 0x25, 0x65,
	0xd3, 0x8a, 0x99, 0x7a, 0xd7, 0xcc, 0xbc, 0x6b, 0xb6, 0xb5, 0xf7, 0xb7, 0xca, 0x2f, 0x5e, 0xad,
	0xcd, 0x7c, 0xf1, 0xdb, 0x9a, 0xe1, 0x5c, 0x90, 0xfc, 0x7e, 0x4a, 0x4f, 0x0f, 0x87, 0x1b, 0xa0,
	0xea, 0x85, 0xcc, 0xdf, 0xe7, 0xf2, 0x38, 0x17, 0xc7, 0xcc, 0x1f, 0xd6, 0xe6, 0xd6, 0x8d, 0x8d,
	0x92, 0xb3, 0x94, 0xe2, 0x5d, 0x9c, 0xd8, 0x12, 0x85, 0x1d, 0x70, 0x3d, 0x42, 0xcf, 0xdc, 0x2c,
	0xbb, 0x5c, 0x9f, 0x51, 0x8e, 0x29, 0x1f, 0x71, 0x77, 0x8c, 0x42, 0x12, 0x20, 0xc1, 0x12, 0x5e,
	0x3b, 0xa3, 0xa8, 0xf5, 0x08, 0x3d, 0xeb, 0x6a, 0xbd, 0x56, 0xa6, 0xf6, 0x61, 0xae, 0xd5, 0xb8,
	0x05, 0x2a, 0x9b, 0x41, 0x90, 0x60, 0xce, 0x77, 0x09, 0x17, 0xf0, 0x2a, 0x98, 0x47, 0xe9, 0x16,
	0xf3, 0x9a, 0xb1, 0x5e, 0xda, 0x58, 0x70, 0xa6, 0x40, 0xe3, 0x23, 0xb0, 0x92, 0x53, 0x7b, 0x58,
	0xb4, 0x86, 0x88, 0x0e, 0x70, 0x17, 0xf9, 0xfb, 0x58, 0x70, 0x78, 0x17, 0xcc, 0x85, 0x84, 0x0b,
	0xc5, 0xaa, 0xdc, 0xb9, 0x61, 0xaa, 0x02, 0x18, 0x37, 0xcd, 0xb7, 0x31, 0xda, 0x48, 0xa0, 0xad,
	0x39, 0xe9, 0x10, 0x47, 0x11, 0x1b, 0x9f, 0x1b, 0xa0, 0xb6, 0x83, 0x27, 0x9b, 0x9c, 0x93, 0x01,
	0x8d, 0x30, 0x15, 0x0e, 0x8e, 0x43, 0xe4, 0x63, 0xb9, 0x84, 0xff, 0x02, 0x8b, 0xf9, 0x75, 0xa5,
	0x41, 0x2a, 0xfe, 0x0b, 0xce, 0x42, 0x06, 0xca, 0x4b, 0xc0, 0xf7, 0x00, 0x88, 0x13, 0x3c, 0x76,
	0x7d, 0x77, 0x1f, 0x4f, 0x54, 0x08, 0x2b, 0x77, 0xae, 0x16, 0x13, 0x22, 0x4d, 0x32, 0xb3, 0x3b,
	0xf2, 0x42, 0xe2, 0xef, 0xe0, 0x89, 0x53, 0x96, 0xfa, 0xad, 0x1d, 0x3c, 0x81, 0xcb, 0xe0, 0x4c,
	0xcc, 0x0e, 0x70, 0xa2, 0x82, 0x58, 0x72, 0xd2, 0x4d, 0xe3, 0x4b, 0x03, 0x5c, 0xce, 0x2f, 0x20,
	0xfd, 0x37, 0x8a, 0x70, 0xd2, 0x1d, 0x79, 0x92, 0xb1, 0x02, 0xca, 0xfe, 0x10, 0x11, 0xea, 0x92,
	0x40, 0x59, 0x33, 0xef, 0x9c, 0x53, 0xfb, 0x4e, 0x70, 0xdc, 0xda, 0xd9, 0x13, 0xac, 0xbd, 0x0b,
	0x16, 0x7c, 0x7d, 0xa2, 0xb2, 0xb7, 0x74, 0x0a, 0x7b, 0x2b, 0x19, 0x63, 0x07, 0x4f, 0x1a, 0x9f,
	0x16, 0x6c, 0xdb, 0x9a, 0x64, 0xd6, 0xa9, 0xb3, 0xdf, 0x6d, 0x5b, 0xfe, 0xdb, 0xa2, 0x6d, 0x7e,
	0x91, 0x7f, 0xec, 0x02, 0xa5, 0xe3, 0x17, 0x68, 0xfc, 0x60, 0x80, 0xe5, 0xe2, 0x5f, 0x79, 0x9f,
	0x75, 0x93, 0x11, 0xc5, 0xef, 0xfa, 0xfb, 0x5d, 0x50, 0x8e, 0xa5, 0x8e, 0x2b, 0xb8, 0x0e, 0xd0,
	0xea, 0xb1, 0x72, 0xe9, 0x67, 0xcd, 0x28, 0xad, 0x97, 0xe7, 0xb2, 0x5e, 0xce, 0x29, 0x56, 0x9f,
	0xc3, 0x36, 0x58, 0x7a, 0xc3, 0x7c, 0xae, 0xfd, 0x76, 0xcd, 0x3c, 0xda, 0x71, 0xcd, 0x42, 0x62,
	0x3b, 0x8b, 0xc5, 0xeb, 0xf1, 0xc6, 0xf7, 0x06, 0x80, 0xc7, 0xcb, 0x01, 0xfe, 0x07, 0xc0, 0x37,
	0x8a, 0xaa, 0x98, 0x6a, 0xd5, 0xb8, 0x50, 0x46, 0xca, 0x49, 0x79, 0xca, 0xcc, 0x16, 0x52, 0x06,
	0xbe, 0x0f, 0x40, 0xac, 0xe2, 0x75, 0xea, 0xa0, 0xce, 0xc7, 0xd9, 0x12, 0xae, 0x81, 0xca, 0x53,
	0x46, 0xa8, 0x3b, 0xc4, 0xb2, 0xa5, 0xe9, 0xf2, 0x07, 0x12, 0xda, 0x56, 0x48, 0x23, 0x00, 0xd5,
	0xcc, 0xe5, 0x0f, 0xb0, 0x40, 0x01, 0x12, 0x08, 0x42, 0x30, 0x47, 0x51, 0x84, 0xb5, 0xab, 0xd5,
	0x1a, 0xae, 0x83, 0x4a, 0x80, 0xb9, 0x9f, 0x90, 0xb8, 0xd0, 0xce, 0x8a, 0x10, 0x5c, 0x05, 0xe5,
	0x48, 0x9f, 0xa0, 0xac, 0x9c, 0x77, 0xf2, 0x7d, 0xe3, 0xcf, 0x12, 0x58, 0xcf, 0x7e, 0xd3, 0xa1,
	0x44, 0x10, 0x14, 0x92, 0x4f, 0x54, 0x0b, 0x53, 0x0d, 0x19, 0x0b, 0x9c, 0x70, 0x78, 0x1f, 0x2c,
	0x91, 0x54, 0x96, 0x99, 0x6b, 0xe8, 0x80, 0xca, 0x9e, 0x2c, 0x87, 0x87, 0xa9, 0x47, 0xc6, 0xb8,
	0x69, 0xa6, 0xe6, 0xeb, 0x7a, 0x5f, 0xd4, 0xbc, 0x14, 0x84, 0xd7, 0xc1, 0xc2, 0x00, 0x53, 0xcc,
	0x09, 0x77, 0x87, 0x88, 0x0f, 0x75, 0x42, 0x56, 0x34, 0xb6, 0x8d, 0xf8, 0x50, 0xfa, 0xc5, 0x23,
	0x14, 0x25, 0x93, 0x54, 0x23, 0xcd, 0x46, 0x90, 0x42, 0x4a, 0xa1, 0x05, 0x00, 0x8f, 0xd1, 0x01,
	0x55, 0x2d, 0x59, 0xf9, 0xed, 0xb4, 0x99, 0x35, 0xaf, 0x78, 0x52, 0x02, 0xf7, 0x40, 0x75, 0x44,
	0x3d, 0x46, 0x83, 0xe9, 0x44, 0x50, 0x6d, 0xf4, 0x94, 0x3d, 0xfd, 0x7c, 0x4e, 0xd6, 0x1d, 0xfd,
	0x2d, 0x63, 0xe2, 0xec, 0x3f, 0x1a, 0x13, 0xb7, 0x01, 0x1c, 0x12, 0x2e, 0x58, 0x42, 0x7c, 0x14,
	0xba, 0x98, 0x8a, 0x84, 0x60, 0x5e, 0x3b, 0xa7, 0x32, 0xe5, 0xc2, 0x54, 0x62, 0xa7, 0x02, 0x5d,
	0xee, 0x14, 0xab, 0xc1, 0x25, 0x0b, 0xb2, 0xac, 0x62, 0xbd, 0x30, 0x05, 0x3b, 0x41, 0x63, 0x0d,
	0x54, 0xf2, 0x70, 0x07, 0x1c, 0x56, 0x41, 0x89, 0x04, 0x69, 0xff, 0x9f, 0x77, 0xe4, 0xb2, 0xf1,
	0x95, 0x01, 0x96, 0x3b, 0x34, 0x9b, 0x8e, 0x85, 0x24, 0xb8, 0x07, 0x2a, 0x01, 0x1b, 0x79, 0x21,
	0x76, 0x65, 0xd7, 0xd6, 0x19, 0x70, 0xe3, 0x78, 0x2d, 0xf6, 0x42, 0xc4, 0x87, 0x1f, 0x20, 0x12,
	0x4e, 0xb9, 0x0e, 0x48, 0x99, 0x3d, 0x32, 0xa0, 0x70, 0x13, 0x94, 0x03, 0x76, 0x40, 0x55, 0xf4,
	0x66, 0xff, 0xce, 0x21, 0x39, 0xad, 0xf1, 0xab, 0x01, 0x2e, 0x9e, 0xa0, 0x01, 0x3f, 0x06, 0x4b,
	0x5c, 0xc2, 0xd3, 0xe1, 0xae, 0x0a, 0x7a, 0xeb, 0x7f, 0xd2, 0xcb, 0xbf, 0xbc, 0x5a, 0xbb, 0x92,
	0x3e, 0xa8, 0x78, 0xb0, 0x6f, 0x12, 0x66, 0x45, 0x48, 0x0c, 0xcd, 0x5d, 0x3c, 0x40, 0xfe, 0xa4,
	0x8d, 0xfd, 0x9f, 0xbe, 0xbb, 0x0d, 0xf4, 0x7b, 0xab, 0x8d, 0xfd, 0x6f, 0xfe, 0xf8, 0xf6, 0xa6,
	0xe1, 0x2c, 0xaa, 0xd3, 0xf2, 0xb7, 0xc0, 0x36, 0x58, 0x7c, 0x8a, 0x48, 0xe8, 0x66, 0x4f, 0x2c,
	0x6d, 0xfe, 0xa9, 0xc2, 0xbb, 0x20, 0x99, 0x19, 0x2e, 0x87, 0xaf, 0x60, 0x91, 0xc7, 0x05, 0xa3,
	0x58, 0xa5, 0x78, 0xd9, 0x99, 0x02, 0x37, 0x7f, 0x34, 0xc0, 0x62, 0x3e, 0x81, 0x86, 0x88, 0x63,
	0x58, 0x07, 0xab, 0xad, 0x87, 0x7b, 0xbd, 0x47, 0x0f, 0x6c, 0xc7, 0xed, 0x6e, 0x6f, 0xf6, 0x6c,
	0xf7, 0xd1, 0x5e, 0xaf, 0x6b, 0xb7, 0x3a, 0xf7, 0x3a, 0x76, 0xbb, 0x3a, 0x03, 0xaf, 0x81, 0x95,
	0x23, 0x72, 0xc7, 0xbe, 0xdf, 0xe9, 0xf5, 0x6d, 0xc7, 0x6e, 0x57, 0x8d, 0x13, 0xe8, 0x9d, 0xbd,
	0x4e, 0xbf, 0xb3, 0xb9, 0xdb, 0x79, 0x6c, 0xb7, 0xab, 0xb3, 0xf0, 0x0a, 0xb8, 0x7c, 0x44, 0xbe,
	0xbb, 0xf9, 0x68, 0xaf, 0xb5, 0x6d, 0xb7, 0xab, 0x25, 0xb8, 0x0a, 0x2e, 0x1d, 0x11, 0xf6, 0xfa,
	0x0f, 0xbb, 0x5d, 0xbb, 0x5d, 0x9d, 0x3b, 0x41, 0xd6, 0xb6, 0x77, 0xed, 0xbe, 0xdd, 0xae, 0x9e,
	0x59, 0x9d, 0xfb, 0xec, 0xeb, 0xfa, 0xcc, 0x56, 0xe7, 0xc5, 0x61, 0xdd, 0x78, 0x79, 0x58, 0x37,
	0x7e, 0x3f, 0xac, 0x1b, 0xcf, 0x5f, 0xd7, 0x67, 0x5e, 0xbe, 0xae, 0xcf, 0xfc, 0xfc, 0xba, 0x3e,
	0xf3, 0xd8, 0x1a, 0x10, 0x31, 0x1c, 0x79, 0xa6, 0xcf, 0x22, 0x0b, 0x85, 0x21, 0xa1, 0x1e, 0x11,
	0xdc, 0x52, 0x6f, 0xc7, 0x67, 0xd6, 0x9b, 0x8f, 0x6e, 0x31, 0x89, 0x31, 0xf7, 0xce, 0x2a, 0xff,
	0xfe, 0xf7, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa7, 0xa1, 0x45, 0x46, 0x92, 0x0b, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxProviderConsensusValidators != 0 {
		i = encodeVarintProvider(dAtA, i, uint64(m.MaxProviderConsensusValidators))
		i--
		dAtA[i] = 0x28
	}
	if m.BlocksPerEpoch != 0 {
		i = encodeVarintProvider(dAtA, i, uint64(m.BlocksPerEpoch))
		i--
		dAtA[i] = 0x20
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.VaasTimeoutPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.VaasTimeoutPeriod):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintProvider(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	if len(m.TrustingPeriodFraction) > 0 {
		i -= len(m.TrustingPeriodFraction)
		copy(dAtA[i:], m.TrustingPeriodFraction)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.TrustingPeriodFraction)))
		i--
		dAtA[i] = 0x12
	}
	if m.TemplateClient != nil {
		{
			size, err := m.TemplateClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddressList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintProvider(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorSetChangePackets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSetChangePackets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorSetChangePackets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProvider(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyAssignmentReplacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyAssignmentReplacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyAssignmentReplacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Power != 0 {
		i = encodeVarintProvider(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x18
	}
	if m.PrevCKey != nil {
		{
			size, err := m.PrevCKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProviderAddr) > 0 {
		i -= len(m.ProviderAddr)
		copy(dAtA[i:], m.ProviderAddr)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ProviderAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorConsumerPubKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorConsumerPubKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorConsumerPubKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsumerKey != nil {
		{
			size, err := m.ConsumerKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProviderAddr) > 0 {
		i -= len(m.ProviderAddr)
		copy(dAtA[i:], m.ProviderAddr)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ProviderAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorByConsumerAddr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorByConsumerAddr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorByConsumerAddr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProviderAddr) > 0 {
		i -= len(m.ProviderAddr)
		copy(dAtA[i:], m.ProviderAddr)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ProviderAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConsumerAddr) > 0 {
		i -= len(m.ConsumerAddr)
		copy(dAtA[i:], m.ConsumerAddr)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ConsumerAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsumerAddrsToPrune) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerAddrsToPrune) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsumerAddrsToPrune) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsumerAddrs != nil {
		{
			size, err := m.ConsumerAddrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PruneTs, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PruneTs):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintProvider(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x12
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JoinHeight != 0 {
		i = encodeVarintProvider(dAtA, i, uint64(m.JoinHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Power != 0 {
		i = encodeVarintProvider(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProviderConsAddr) > 0 {
		i -= len(m.ProviderConsAddr)
		copy(dAtA[i:], m.ProviderConsAddr)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ProviderConsAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsumerMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsumerMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsumerInitializationParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerInitializationParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsumerInitializationParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x42
	}
	if m.HistoricalEntries != 0 {
		i = encodeVarintProvider(dAtA, i, uint64(m.HistoricalEntries))
		i--
		dAtA[i] = 0x38
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.VaasTimeoutPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.VaasTimeoutPeriod):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintProvider(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x32
	n9, err9 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.UnbondingPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.UnbondingPeriod):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintProvider(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x2a
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.SpawnTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SpawnTime):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintProvider(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x22
	if len(m.BinaryHash) > 0 {
		i -= len(m.BinaryHash)
		copy(dAtA[i:], m.BinaryHash)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.BinaryHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GenesisHash) > 0 {
		i -= len(m.GenesisHash)
		copy(dAtA[i:], m.GenesisHash)
		i = encodeVarintProvider(dAtA, i, uint64(len(m.GenesisHash)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.InitialHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProvider(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConsumerIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsumerIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ids[iNdEx])
			copy(dAtA[i:], m.Ids[iNdEx])
			i = encodeVarintProvider(dAtA, i, uint64(len(m.Ids[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InfractionParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfractionParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfractionParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Downtime != nil {
		{
			size, err := m.Downtime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DoubleSign != nil {
		{
			size, err := m.DoubleSign.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashJailParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashJailParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashJailParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tombstone {
		i--
		if m.Tombstone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	n14, err14 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.JailDuration, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.JailDuration):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintProvider(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x12
	{
		size := m.SlashFraction.Size()
		i -= size
		if _, err := m.SlashFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProvider(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintProvider(dAtA []byte, offset int, v uint64) int {
	offset -= sovProvider(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TemplateClient != nil {
		l = m.TemplateClient.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.TrustingPeriodFraction)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.VaasTimeoutPeriod)
	n += 1 + l + sovProvider(uint64(l))
	if m.BlocksPerEpoch != 0 {
		n += 1 + sovProvider(uint64(m.BlocksPerEpoch))
	}
	if m.MaxProviderConsensusValidators != 0 {
		n += 1 + sovProvider(uint64(m.MaxProviderConsensusValidators))
	}
	return n
}

func (m *AddressList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, b := range m.Addresses {
			l = len(b)
			n += 1 + l + sovProvider(uint64(l))
		}
	}
	return n
}

func (m *ValidatorSetChangePackets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovProvider(uint64(l))
		}
	}
	return n
}

func (m *KeyAssignmentReplacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderAddr)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	if m.PrevCKey != nil {
		l = m.PrevCKey.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovProvider(uint64(m.Power))
	}
	return n
}

func (m *ValidatorConsumerPubKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.ProviderAddr)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	if m.ConsumerKey != nil {
		l = m.ConsumerKey.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	return n
}

func (m *ValidatorByConsumerAddr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.ConsumerAddr)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.ProviderAddr)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	return n
}

func (m *ConsumerAddrsToPrune) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PruneTs)
	n += 1 + l + sovProvider(uint64(l))
	if m.ConsumerAddrs != nil {
		l = m.ConsumerAddrs.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	return n
}

func (m *ConsensusValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderConsAddr)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovProvider(uint64(m.Power))
	}
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	if m.JoinHeight != 0 {
		n += 1 + sovProvider(uint64(m.JoinHeight))
	}
	return n
}

func (m *ConsumerMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	return n
}

func (m *ConsumerInitializationParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.InitialHeight.Size()
	n += 1 + l + sovProvider(uint64(l))
	l = len(m.GenesisHash)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = len(m.BinaryHash)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SpawnTime)
	n += 1 + l + sovProvider(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.UnbondingPeriod)
	n += 1 + l + sovProvider(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.VaasTimeoutPeriod)
	n += 1 + l + sovProvider(uint64(l))
	if m.HistoricalEntries != 0 {
		n += 1 + sovProvider(uint64(m.HistoricalEntries))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovProvider(uint64(l))
	}
	return n
}

func (m *ConsumerIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			l = len(s)
			n += 1 + l + sovProvider(uint64(l))
		}
	}
	return n
}

func (m *InfractionParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoubleSign != nil {
		l = m.DoubleSign.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	if m.Downtime != nil {
		l = m.Downtime.Size()
		n += 1 + l + sovProvider(uint64(l))
	}
	return n
}

func (m *SlashJailParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SlashFraction.Size()
	n += 1 + l + sovProvider(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.JailDuration)
	n += 1 + l + sovProvider(uint64(l))
	if m.Tombstone {
		n += 2
	}
	return n
}

func sovProvider(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProvider(x uint64) (n int) {
	return sovProvider(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateClient == nil {
				m.TemplateClient = &_07_tendermint.ClientState{}
			}
			if err := m.TemplateClient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustingPeriodFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustingPeriodFraction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaasTimeoutPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.VaasTimeoutPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlocksPerEpoch", wireType)
			}
			m.BlocksPerEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlocksPerEpoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProviderConsensusValidators", wireType)
			}
			m.MaxProviderConsensusValidators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProviderConsensusValidators |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, make([]byte, postIndex-iNdEx))
			copy(m.Addresses[len(m.Addresses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorSetChangePackets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSetChangePackets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSetChangePackets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, types.ValidatorSetChangePacketData{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyAssignmentReplacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyAssignmentReplacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyAssignmentReplacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddr = append(m.ProviderAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.ProviderAddr == nil {
				m.ProviderAddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevCKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevCKey == nil {
				m.PrevCKey = &crypto.PublicKey{}
			}
			if err := m.PrevCKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorConsumerPubKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorConsumerPubKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorConsumerPubKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddr = append(m.ProviderAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.ProviderAddr == nil {
				m.ProviderAddr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsumerKey == nil {
				m.ConsumerKey = &crypto.PublicKey{}
			}
			if err := m.ConsumerKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorByConsumerAddr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorByConsumerAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorByConsumerAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerAddr = append(m.ConsumerAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerAddr == nil {
				m.ConsumerAddr = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddr = append(m.ProviderAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.ProviderAddr == nil {
				m.ProviderAddr = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerAddrsToPrune) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerAddrsToPrune: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerAddrsToPrune: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruneTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PruneTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsumerAddrs == nil {
				m.ConsumerAddrs = &AddressList{}
			}
			if err := m.ConsumerAddrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderConsAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderConsAddr = append(m.ProviderConsAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.ProviderConsAddr == nil {
				m.ProviderConsAddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &crypto.PublicKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinHeight", wireType)
			}
			m.JoinHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerInitializationParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerInitializationParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerInitializationParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisHash = append(m.GenesisHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GenesisHash == nil {
				m.GenesisHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryHash = append(m.BinaryHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BinaryHash == nil {
				m.BinaryHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpawnTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.SpawnTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.UnbondingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaasTimeoutPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.VaasTimeoutPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalEntries", wireType)
			}
			m.HistoricalEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoricalEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfractionParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfractionParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfractionParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleSign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DoubleSign == nil {
				m.DoubleSign = &SlashJailParameters{}
			}
			if err := m.DoubleSign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Downtime == nil {
				m.Downtime = &SlashJailParameters{}
			}
			if err := m.Downtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashJailParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashJailParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashJailParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFraction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SlashFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.JailDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tombstone = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProvider(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProvider
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProvider
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProvider
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProvider
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProvider
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProvider        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProvider          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProvider = fmt.Errorf("proto: unexpected end of group")
)
